import argparse

def parse_args():
    """
    Parse command-line arguments:
      --layer_sizes: comma-separated list of node counts per layer (e.g., "1,2,4")
      --layer_lengths: comma-separated list of sequence lengths per layer (e.g., "128,64,64")
      --output_file: path to the output file
    """
    parser = argparse.ArgumentParser(description="Generate a tree based on layer sizes and sequence lengths.")
    parser.add_argument('-n', '--layer_sizes', type=str, required=True,
                        help="Comma-separated list of node counts per layer (e.g., '1,2,4').")
    parser.add_argument('-l', '--layer_lengths', type=str, required=True,
                        help="Comma-separated list of sequence lengths per layer (e.g., '128,64,64').")
    parser.add_argument('-o', '--output_file', type=str, required=True,
                        help="Path to the output file where the tree will be saved.")
    return parser.parse_args()

def generate_tree(layer_sizes, layer_lengths):
    """
    Generate a tree based on the given layer sizes and layer lengths.
    
    Args:
        layer_sizes (list): a list of integers representing node counts per layer
        layer_lengths (list): a list of integers representing sequence length for each layer

    Returns:
        list: a list of nodes, where each node is represented as:
              [parent_id, node_id, seq_length, out_degree]
              - parent_id: the ID of the parent node (-1 for the root)
              - node_id: the node's own ID
              - seq_length: sequence length of this node
              - out_degree: the number of children (initially 0, updated when children are assigned)
    """
    if len(layer_sizes) != len(layer_lengths):
        raise ValueError("The length of layer_sizes must be equal to the length of layer_lengths.")
    
    total_nodes = sum(layer_sizes)
    # Initialize a list of nodes: [parent, node_id, seq_length, out_degree]
    nodes = [[-1, -1, -1, 0] for _ in range(total_nodes)]
    
    current_id = 0  # This will be used for assigning node IDs
    prev_layer_ids = []  # This will store the node IDs of the previous layer
    
    for layer_idx, (size, seq_len) in enumerate(zip(layer_sizes, layer_lengths)):
        current_layer_ids = []
        
        for j in range(size):
            node_id = current_id
            current_id += 1
            
            # Determine parent
            if layer_idx == 0:
                # For the first layer (root layer), the parent is -1
                parent_id = -1
            else:
                # Distribute children among the previous layer's nodes
                # This formula ensures a roughly even distribution of children
                p_index = (j * len(prev_layer_ids)) // size
                parent_id = prev_layer_ids[p_index]
                
                # Update the parent's out_degree
                nodes[parent_id][3] += 1
            
            # Fill information for the current node
            nodes[node_id][0] = parent_id    # parent_id
            nodes[node_id][1] = node_id      # node_id
            nodes[node_id][2] = seq_len      # sequence length
            # out_degree is already 0; updated for parent if needed
            
            current_layer_ids.append(node_id)
        
        # Prepare for the next iteration
        prev_layer_ids = current_layer_ids
    
    return nodes

def save_tree(nodes, output_path):
    """
    Save the generated tree to a file in the specified format.
    The format:
        Line 1: total number of nodes n
        Next n lines: "parent_id node_id seq_length out_degree"

    Args:
        nodes (list): the list of nodes generated by generate_tree()
        output_path (str): the file path to save the tree
    """
    with open(output_path, 'w', encoding='utf-8') as f:
        # First line: number of nodes
        f.write(str(len(nodes)) + "\n")
        # Following lines: node information
        for parent, node_id, seq_len, out_degree in nodes:
            f.write(f"{parent} {node_id} {seq_len} {out_degree}\n")

def main():
    """
    Main function to parse arguments, generate the tree, and save to file.
    """
    args = parse_args()
    
    # Convert comma-separated strings to lists of integers
    layer_sizes = list(map(int, args.layer_sizes.split(',')))
    layer_lengths = list(map(int, args.layer_lengths.split(',')))
    
    # Generate the tree
    tree_nodes = generate_tree(layer_sizes, layer_lengths)
    
    # Save the tree to the specified output file
    save_tree(tree_nodes, args.output_file)

if __name__ == "__main__":
    main()